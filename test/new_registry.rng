<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
    <div>
        <a:documentation>All elements and primary content models</a:documentation>
        <start>
            <ref name="reg.root-element.model"/>
        </start>
        <define name="reg.root-element.model">
            <ref name="reg.registry.elem"/>
        </define>
        <define name="reg.registry.elem">
            <element name="registry">
                <a:documentation>Base element. Contains all of the information for Vulkan.</a:documentation>
                <ref name="reg.registry.contents"/>
            </element>
        </define>
        <define name="reg.registry.contents">
            <ref name="reg.registry.attlist"/>
            <optional>
                <ref name="reg.notation.elem"/>
            </optional>
            <optional>
                <ref name="reg.vendorids.elem"/>
            </optional>
            <optional>
                <ref name="reg.tags.elem"/>
            </optional>
            <ref name="reg.definitions.elem"/>
            <optional>
                <ref name="reg.constants.elem"/>
            </optional>
            <optional>
                <ref name="reg.enums.elem"/>
            </optional>
            <ref name="reg.commands.elem"/>
            <ref name="reg.features.elem"/>
            <optional>
                <ref name="reg.extensions.elem"/>
            </optional>
        </define>
        <define name="reg.registry.attlist">
            <empty/>
        </define>
        <define name="reg.notation.elem">
            <element name="notation">
                <a:documentation>A textual annotation regarding a particular element.</a:documentation>
                <text/>
            </element>
        </define>
        <define name="reg.named.ident.model">
            <a:documentation>Attributes for (almost) any element that represents an identifier in Vulkan.
All such identifiers can have a notation.</a:documentation>
            <ref name="reg.api.name.attrib"/>
            <optional>
                <ref name="reg.notation.attrib"/>
            </optional>
        </define>
        <div>
            <a:documentation>Front matter: vendorids and tags.</a:documentation>
            <define name="reg.vendorids.elem">
                <element name="vendorids">
                    <a:documentation>The list of all vendorid elements.</a:documentation>
                    <ref name="reg.vendorids.contents"/>
                </element>
            </define>
            <define name="reg.vendorids.contents">
                <ref name="reg.vendorids.attlist"/>
                <oneOrMore>
                    <ref name="reg.vendorid.elem"/>
                </oneOrMore>
            </define>
            <define name="reg.vendorids.attlist">
                <empty/>
            </define>
            <define name="reg.vendorid.elem">
                <element name="vendorid">
                    <a:documentation>List of identifiers for vendors.</a:documentation>
                    <ref name="reg.vendorid.contents"/>
                </element>
            </define>
            <define name="reg.vendorid.contents">
                <ref name="reg.vendorid.attlist"/>
            </define>
            <define name="reg.vendorid.attlist">
                <ref name="reg.any.name.attrib"/>
                <ref name="reg.vendorid.id.attrib"/>
                <optional>
                    <ref name="reg.notation.attrib"/>
                </optional>
            </define>
            <define name="reg.tags.elem">
                <element name="tags">
                    <a:documentation>List of authors</a:documentation>
                    <ref name="reg.tags.contents"/>
                </element>
            </define>
            <define name="reg.tags.contents">
                <ref name="reg.tags.attlist"/>
                <oneOrMore>
                    <ref name="reg.tag.elem"/>
                </oneOrMore>
            </define>
            <define name="reg.tags.attlist">
                <empty/>
            </define>
            <define name="reg.tag.elem">
                <element name="tag">
                    <a:documentation>A single author for Vulkan</a:documentation>
                    <ref name="reg.tag.contents"/>
                </element>
            </define>
            <define name="reg.tag.contents">
                <ref name="reg.tag.attlist"/>
            </define>
            <define name="reg.tag.attlist">
                <ref name="reg.any.name.attrib"/>
                <ref name="reg.tag.author.attrib"/>
                <ref name="reg.tag.contact.attrib"/>
                <optional>
                    <ref name="reg.notation.attrib"/>
                </optional>
            </define>
        </div>
        <div>
            <a:documentation>Definition elements.</a:documentation>
            <define name="reg.definitions.elem">
                <element name="definitions">
                    <a:documentation>List of all definitions used by Vulkan </a:documentation>
                    <ref name="reg.definitions.contents"/>
                </element>
            </define>
            <define name="reg.definitions.contents">
                <ref name="reg.definitions.attlist"/>
                <oneOrMore>
                    <ref name="reg.definitions.model"/>
                </oneOrMore>
            </define>
            <define name="reg.definitions.attlist">
                <empty/>
            </define>
            <define name="reg.definitions.model">
                <choice>
                    <ref name="reg.include.elem"/>
                    <ref name="reg.typedef.elem">
                        <a:documentation>Formerly `basetype`</a:documentation>
                    </ref>
                    <ref name="reg.reference.elem">
                        <a:documentation>Formerly no category. Simply specifies the existence of a named type that
usually is brought in by a `requires` attribute.</a:documentation>
                    </ref>
                    <ref name="reg.def.bitmask.elem"/>
                    <ref name="reg.struct.elem"/>
                    <ref name="reg.union.elem"/>
                    <ref name="reg.define.elem"/>
                    <ref name="reg.handle.elem"/>
                    <ref name="reg.def.enumeration.elem"/>
                    <ref name="reg.funcptr.elem"/>
                </choice>
            </define>
            <define name="reg.include.elem">
                <element name="include">
                    <a:documentation>Definition that represents a file being included, which is named.
The `name` attribute does double-duty, in that it also includes text.</a:documentation>
                    <ref name="reg.include.contents"/>
                </element>
            </define>
            <define name="reg.include.contents">
                <ref name="reg.include.attlist"/>
            </define>
            <define name="reg.include.attlist">
                <ref name="reg.any.name.attrib">
                    <a:documentation>An include's `name` is a full pathname, not just an C/C++ identifier.</a:documentation>
                </ref>
                <optional>
                    <ref name="reg.notation.attrib"/>
                </optional>
                <ref name="reg.include.style.attrib"/>
                <optional>
                    <ref name="reg.include.need-ext.attrib"/>
                </optional>
            </define>
            <define name="reg.typedef.elem">
                <element name="typedef">
                    <a:documentation>Definition that defines a new name for an existing type. </a:documentation>
                    <ref name="reg.typedef.contents"/>
                </element>
            </define>
            <define name="reg.typedef.contents">
                <ref name="reg.typedef.attlist"/>
            </define>
            <define name="reg.typedef.attlist">
                <ref name="reg.named.ident.model"/>
                <ref name="reg.typedef.basetype.attrib"/>
            </define>
            <define name="reg.reference.elem">
                <element name="reference">
                    <a:documentation>Definition that references a type that comes from an include file.</a:documentation>
                    <ref name="reg.reference.contents"/>
                </element>
            </define>
            <define name="reg.reference.contents">
                <ref name="reg.reference.attlist"/>
            </define>
            <define name="reg.reference.attlist">
                <ref name="reg.named.ident.model"/>
                <ref name="reg.reference.include.attrib"/>
            </define>
            <define name="reg.def.bitmask.elem">
                <element name="bitmask">
                    <a:documentation>Definition that specifies a bitmask, using a particular existing type.
Contents are the same as `typedef`.
The possible bits can be defined by a specific, referenced enumeration.</a:documentation>
                    <ref name="reg.def.bitmask.contents"/>
                </element>
            </define>
            <define name="reg.def.bitmask.contents">
                <ref name="reg.def.bitmask.attlist"/>
            </define>
            <define name="reg.def.bitmask.attlist">
                <ref name="reg.typedef.attlist"/>
                <optional>
                    <ref name="reg.bitmask.enumref.attrib"/>
                </optional>
            </define>
            <define name="reg.define.elem">
                <element name="define">
                    <a:documentation>Definition that represents a C #define statement.</a:documentation>
                    <ref name="reg.define.contents"/>
                </element>
            </define>
            <define name="reg.define.contents">
                <a:documentation>The 3 forms of defines:
#define name C-expression
#define name(params) C-expression
C-expression

In all cases, C-expression should be verbatim copied. The question is whether the text
contains the actual "#define" internally or not.
Defines can also reference other definitions.    </a:documentation>
                <ref name="reg.define.attlist"/>
                <optional>
                    <ref name="reg.comment.elem"/>
                </optional>
                <ref name="reg.define.model"/>
            </define>
            <define name="reg.define.attlist">
                <ref name="reg.named.ident.model"/>
                <optional>
                    <ref name="reg.define.disabled.attrib"/>
                </optional>
            </define>
            <define name="reg.comment.elem">
                <element name="comment">
                    <a:documentation>Specifies a possibly multi-line in-language comment which is expected to be
placed near the element in which `comment` appears.</a:documentation>
                    <text/>
                </element>
            </define>
            <define name="reg.define.model">
                <choice>
                    <ref name="reg.define.value.attrib"/>
                    <ref name="reg.define.complex.model"/>
                </choice>
            </define>
            <define name="reg.define.complex.model">
                <optional>
                    <ref name="reg.define.replace.attrib"/>
                </optional>
                <zeroOrMore>
                    <ref name="reg.define.defref.elem"/>
                </zeroOrMore>
                <zeroOrMore>
                    <ref name="reg.define.param.elem"/>
                </zeroOrMore>
                <ref name="reg.c-expression.elem"/>
            </define>
            <define name="reg.define.defref.elem">
                <element name="defref">
                    <a:documentation>Specifies a definition that is referenced in the C-expression.</a:documentation>
                    <ref name="reg.identifier.data"/>
                </element>
            </define>
            <define name="reg.define.param.elem">
                <element name="param">
                    <a:documentation>The name of a #define's parameter.</a:documentation>
                    <ref name="reg.identifier.data"/>
                </element>
            </define>
            <define name="reg.c-expression.elem">
                <element name="c-expression">
                    <a:documentation>Text that is intended to be used verbatim in C or C++ implementations.
If the `replace` attribute is not `true`, then the processor should
generate the `#define NAME(PARAMS)` part of the define before the c-expression.</a:documentation>
                    <text/>
                </element>
            </define>
            <define name="reg.handle.elem">
                <element name="handle">
                    <a:documentation>Creates a definition for a handle.</a:documentation>
                    <ref name="reg.handle.contents"/>
                </element>
            </define>
            <define name="reg.handle.contents">
                <ref name="reg.handle.attlist"/>
            </define>
            <define name="reg.handle.attlist">
                <ref name="reg.named.ident.model"/>
                <optional>
                    <ref name="reg.handle.parent.attrib"/>
                </optional>
                <ref name="reg.handle.type.attrib"/>
            </define>
            <define name="reg.def.enumeration.elem">
                <element name="enumeration">
                    <a:documentation>Defines the name of an enumeration.
The members and base type of the enumeration are defined elsewhere.</a:documentation>
                    <ref name="reg.def.enumeration.contents"/>
                </element>
            </define>
            <define name="reg.def.enumeration.contents">
                <ref name="reg.def.enumeration.attlist"/>
            </define>
            <define name="reg.def.enumeration.attlist">
                <ref name="reg.named.ident.model"/>
            </define>
            <define name="reg.struct.elem">
                <element name="struct">
                    <a:documentation>Definition that represents a data structure.
Contains a list of members and optional validation information.</a:documentation>
                    <ref name="reg.struct.contents"/>
                </element>
            </define>
            <define name="reg.struct.contents">
                <ref name="reg.struct.attlist"/>
                <oneOrMore>
                    <ref name="reg.struct.member.elem"/>
                </oneOrMore>
                <optional>
                    <ref name="reg.validity.elem"/>
                </optional>
            </define>
            <define name="reg.struct.attlist">
                <ref name="reg.named.ident.model"/>
                <optional>
                    <ref name="reg.struct.is-return.attrib"/>
                </optional>
            </define>
            <define name="reg.struct.member.elem">
                <element name="member">
                    <a:documentation>Specifies a named member of a data structure.</a:documentation>
                    <ref name="reg.struct.member.contents"/>
                </element>
            </define>
            <define name="reg.struct.member.contents">
                <ref name="reg.struct.member.attlist"/>
            </define>
            <define name="reg.struct.member.attlist">
                <ref name="reg.named.ident.model"/>
                <ref name="reg.typed.variable.model"/>
                <optional>
                    <ref name="reg.struct.member.extension-structs.attrib"/>
                </optional>
                <optional>
                    <ref name="reg.struct.member.type-enums.attrib"/>
                </optional>
            </define>
            <define name="reg.type.model">
                <a:documentation>All of the attributes that represent the type of a
struct member, function parameter or return value.</a:documentation>
                <ref name="reg.type.basetype.attrib"/>
                <optional>
                    <ref name="reg.type.array.model"/>
                </optional>
                <optional>
                    <ref name="reg.type.const.attrib"/>
                </optional>
                <optional>
                    <ref name="reg.type.struct.attrib"/>
                </optional>
                <optional>
                    <ref name="reg.type.reference.attrib"/>
                </optional>
            </define>
            <define name="reg.type.array.model">
                <a:documentation>Can either be a static array or a dynamic array.
Which one is used changes the meaning of the `size` attribute.
Static arrays must have a `size`; dynamic do not.</a:documentation>
                <choice>
                    <ref name="reg.type.static.array.model"/>
                    <ref name="reg.type.dynamic.array.model"/>
                </choice>
            </define>
            <define name="reg.type.static.array.model">
                <a:documentation>Static arrays have `array` set to "static" and the sizing attribute.</a:documentation>
                <ref name="reg.type.static.array.attrib"/>
                <ref name="reg.type.static.array.size.model"/>
            </define>
            <define name="reg.type.static.array.size.model">
                <a:documentation>Static sizes can be integer constants or enumerator references.</a:documentation>
                <choice>
                    <ref name="reg.type.static.array.size.attrib"/>
                    <ref name="reg.type.static.array.size-enumref.attrib"/>
                </choice>
            </define>
            <define name="reg.type.dynamic.array.model">
                <a:documentation>Dynamic arrays have `array` set to "dynamic", and may have
the `null-terminate` attribute, `size` attribute, or both.
If it has neither, then the size is not determinable.
If it has both, then the `null-terminate` size refers to a `char*` of
some form, with the `size` referring to the outer array.</a:documentation>
                <ref name="reg.type.dynamic.array.attrib"/>
                <optional>
                    <ref name="reg.type.dynamic.array.size.attrib"/>
                </optional>
                <optional>
                    <ref name="reg.type.dynamic.array.null-terminate.attrib"/>
                </optional>
            </define>
            <define name="reg.typed.variable.model">
                <a:documentation>Data model describing type information for a variable.
Variables have a type, but they also have additional data about
the purpose of the variable.</a:documentation>
                <ref name="reg.type.model"/>
                <optional>
                    <ref name="reg.variable.optional.attrib"/>
                </optional>
                <optional>
                    <ref name="reg.variable.auto-validity.attrib"/>
                </optional>
                <optional>
                    <ref name="reg.variable.inout.attrib"/>
                </optional>
                <optional>
                    <ref name="reg.variable.sync.attrib"/>
                </optional>
            </define>
            <define name="reg.validity.elem">
                <element name="validity">
                    <a:documentation>Defines validation text related to objects and commands.</a:documentation>
                    <ref name="reg.validity.contents"/>
                </element>
            </define>
            <define name="reg.validity.contents">
                <ref name="reg.validity.attlist"/>
                <oneOrMore>
                    <ref name="reg.validity.usage.elem"/>
                </oneOrMore>
            </define>
            <define name="reg.validity.attlist">
                <empty/>
            </define>
            <define name="reg.validity.usage.elem">
                <element name="usage">
                    <a:documentation>A specific validation rule, spelled out in documentation text.</a:documentation>
                    <ref name="reg.validity.usage.contents"/>
                </element>
            </define>
            <define name="reg.validity.usage.contents">
                <ref name="reg.validity.usage.attlist"/>
                <ref name="reg.spec-language.data"/>
            </define>
            <define name="reg.validity.usage.attlist">
                <empty/>
            </define>
            <define name="reg.union.elem">
                <element name="union">
                    <a:documentation>Defines a union, where the object's value is only one of the members.</a:documentation>
                    <ref name="reg.union.contents"/>
                </element>
            </define>
            <define name="reg.union.contents">
                <ref name="reg.union.attlist"/>
                <oneOrMore>
                    <ref name="reg.union.member.elem"/>
                </oneOrMore>
            </define>
            <define name="reg.union.attlist">
                <ref name="reg.named.ident.model"/>
            </define>
            <define name="reg.union.member.elem">
                <element name="member">
                    <a:documentation>Specifies a named member of a union.</a:documentation>
                    <ref name="reg.union.member.contents"/>
                </element>
            </define>
            <define name="reg.union.member.contents">
                <ref name="reg.union.member.attlist"/>
            </define>
            <define name="reg.union.member.attlist">
                <ref name="reg.named.ident.model"/>
                <ref name="reg.type.model"/>
            </define>
            <define name="reg.funcptr.elem">
                <element name="funcptr">
                    <a:documentation>Defines a function pointer.</a:documentation>
                    <ref name="reg.funcptr.contents"/>
                </element>
            </define>
            <define name="reg.funcptr.contents">
                <a:documentation>If it has no function parameters, then it should be rendered out for C/C++ with just
"void" in the parameter list. And just "void" should not be in a `&lt;type&gt;` element, as it
does not qualify as a parameter type.</a:documentation>
                <ref name="reg.funcptr.attlist"/>
                <ref name="reg.return-type.elem"/>
                <zeroOrMore>
                    <ref name="reg.param.elem"/>
                </zeroOrMore>
            </define>
            <define name="reg.funcptr.attlist">
                <ref name="reg.named.ident.model"/>
            </define>
            <define name="reg.return-type.elem">
                <element name="return-type">
                    <ref name="reg.return-type.contents"/>
                </element>
            </define>
            <define name="reg.return-type.contents">
                <ref name="reg.return-type.attlist"/>
            </define>
            <define name="reg.return-type.attlist">
                <ref name="reg.type.model"/>
                <optional>
                    <ref name="reg.error-code.model"/>
                </optional>
            </define>
            <define name="reg.error-code.model">
                <ref name="reg.command.successcodes.attrib"/>
                <ref name="reg.command.errorcodes.attrib"/>
            </define>
            <define name="reg.param.elem">
                <element name="param">
                    <ref name="reg.param.contents"/>
                </element>
            </define>
            <define name="reg.param.contents">
                <ref name="reg.param.attlist"/>
            </define>
            <define name="reg.param.attlist">
                <optional>
                    <ref name="reg.named.ident.model">
                        <a:documentation>Parameter names are not required for functions.</a:documentation>
                    </ref>
                </optional>
                <ref name="reg.typed.variable.model"/>
            </define>
        </div>
        <div>
            <a:documentation>Constants and Enumeration elements.</a:documentation>
            <define name="reg.constants.elem">
                <element name="constants">
                    <ref name="reg.constants.contents"/>
                </element>
            </define>
            <define name="reg.constants.contents">
                <ref name="reg.constants.attlist"/>
                <oneOrMore>
                    <ref name="reg.constant.elem"/>
                </oneOrMore>
            </define>
            <define name="reg.constants.attlist">
                <empty/>
            </define>
            <define name="reg.constant.elem">
                <element name="constant">
                    <a:documentation>Contains a named constant value that is not typed to an enumeration.</a:documentation>
                    <ref name="reg.constant.contents"/>
                </element>
            </define>
            <define name="reg.constant.contents">
                <ref name="reg.constant.attlist"/>
            </define>
            <define name="reg.constant.attlist">
                <ref name="reg.named.ident.model"/>
                <ref name="reg.enum.value.model"/>
            </define>
            <define name="reg.enum.value.model">
                <a:documentation>Enumerators can be decimal integers, C-expressions, bit positions, or hexadecimal bitmasks.</a:documentation>
                <choice>
                    <ref name="reg.enum.number.attrib">
                        <a:documentation>Decimal integer</a:documentation>
                    </ref>
                    <ref name="reg.enum.hex.attrib">
                        <a:documentation>Unsigned hexadecimal value, mainly for bitmasks.</a:documentation>
                    </ref>
                    <ref name="reg.enum.bitpos.attrib">
                        <a:documentation>Bit position, to be transformed into a number by `1 &lt;&lt; bitpos`.</a:documentation>
                    </ref>
                    <ref name="reg.enum.c-expression.attrib">
                        <a:documentation>C-expression that results in a number.</a:documentation>
                    </ref>
                </choice>
            </define>
            <define name="reg.enums.elem">
                <element name="enums">
                    <a:documentation>Contains both enumerations and bitmasks.</a:documentation>
                    <ref name="reg.enums.contents"/>
                </element>
            </define>
            <define name="reg.enums.contents">
                <ref name="reg.enums.attlist"/>
                <oneOrMore>
                    <ref name="reg.enumeration.elem"/>
                </oneOrMore>
            </define>
            <define name="reg.enums.attlist">
                <empty/>
            </define>
            <define name="reg.enumeration.elem">
                <element name="enumeration">
                    <ref name="reg.enumeration.contents"/>
                </element>
            </define>
            <define name="reg.enumeration.contents">
                <ref name="reg.enumeration.attlist"/>
                <zeroOrMore>
                    <ref name="reg.enumeration.enum.elem">
                        <a:documentation>Empty enumerations are OK; extensions could fill them.</a:documentation>
                    </ref>
                </zeroOrMore>
                <zeroOrMore>
                    <ref name="reg.enumeration.unused-range.elem"/>
                </zeroOrMore>
            </define>
            <define name="reg.enumeration.attlist">
                <ref name="reg.named.ident.model"/>
                <optional>
                    <ref name="reg.enum.purpose.attrib"/>
                </optional>
                <optional>
                    <ref name="reg.enum.range.model"/>
                </optional>
            </define>
            <define name="reg.enum.range.model">
                <ref name="reg.enum.range-start.attrib">
                    <a:documentation>Represents a range of enumerators.</a:documentation>
                </ref>
                <optional>
                    <ref name="reg.enum.range-end.attrib"/>
                </optional>
            </define>
            <define name="reg.enumeration.enum.elem">
                <element name="enum">
                    <ref name="reg.enumeration.enum.contents"/>
                </element>
            </define>
            <define name="reg.enumeration.enum.contents">
                <ref name="reg.enumeration.enum.attlist"/>
            </define>
            <define name="reg.enumeration.enum.attlist">
                <ref name="reg.named.ident.model"/>
                <ref name="reg.enum.value.model"/>
            </define>
            <define name="reg.enumeration.unused-range.elem">
                <element name="unused-range">
                    <ref name="reg.enumeration.unused-range.contents"/>
                </element>
            </define>
            <define name="reg.enumeration.unused-range.contents">
                <ref name="reg.enumeration.unused-range.attlist"/>
            </define>
            <define name="reg.enumeration.unused-range.attlist">
                <ref name="reg.enum.range.model"/>
            </define>
        </div>
        <div>
            <a:documentation>Command elements</a:documentation>
            <define name="reg.commands.elem">
                <element name="commands">
                    <a:documentation>Defines a list of Vulkan entrypoints.</a:documentation>
                    <ref name="reg.commands.contents"/>
                </element>
            </define>
            <define name="reg.commands.contents">
                <ref name="reg.commands.attlist"/>
                <oneOrMore>
                    <choice>
                        <ref name="reg.command.elem"/>
                        <ref name="reg.command-alias.elem"/>
                    </choice>
                </oneOrMore>
            </define>
            <define name="reg.commands.attlist">
                <empty/>
            </define>
            <define name="reg.command.elem">
                <element name="command">
                    <a:documentation>Defines a single Vulkan entrypoint.</a:documentation>
                    <ref name="reg.command.contents"/>
                </element>
            </define>
            <define name="reg.command.contents">
                <ref name="reg.command.attlist"/>
                <ref name="reg.return-type.elem"/>
                <zeroOrMore>
                    <ref name="reg.param.elem"/>
                </zeroOrMore>
                <interleave>
                    <optional>
                        <ref name="reg.command.description.elem"/>
                    </optional>
                    <optional>
                        <ref name="reg.command.external-sync.elem"/>
                    </optional>
                    <optional>
                        <ref name="reg.validity.elem"/>
                    </optional>
                </interleave>
            </define>
            <define name="reg.command.attlist">
                <ref name="reg.named.ident.model"/>
                <optional>
                    <ref name="reg.command.renderpass.attrib"/>
                </optional>
                <optional>
                    <ref name="reg.command.cmdbufferlevel.attrib"/>
                </optional>
                <optional>
                    <ref name="reg.command.queues.attrib"/>
                </optional>
            </define>
            <define name="reg.command.description.elem">
                <element name="description">
                    <a:documentation>Textual description of the command... in some form?</a:documentation>
                    <ref name="reg.command.description.contents"/>
                </element>
            </define>
            <define name="reg.command.description.contents">
                <ref name="reg.command.description.attlist"/>
                <ref name="reg.spec-language.data"/>
            </define>
            <define name="reg.command.description.attlist">
                <empty/>
            </define>
            <define name="reg.command.external-sync.elem">
                <element name="external-sync">
                    <a:documentation>Describes instances of implicit external synchronizations.
These cannot be captured by the parameters themselves.</a:documentation>
                    <ref name="reg.command.external-sync.contents"/>
                </element>
            </define>
            <define name="reg.command.external-sync.contents">
                <ref name="reg.command.external-sync.attlist"/>
                <oneOrMore>
                    <ref name="reg.external-sync.sync.elem"/>
                </oneOrMore>
            </define>
            <define name="reg.command.external-sync.attlist">
                <empty/>
            </define>
            <define name="reg.external-sync.sync.elem">
                <element name="sync">
                    <a:documentation>A single aspect of implicit external synchronization.</a:documentation>
                    <ref name="reg.external-sync.sync.contents"/>
                </element>
            </define>
            <define name="reg.external-sync.sync.contents">
                <ref name="reg.external-sync.sync.attlist"/>
                <ref name="reg.spec-language.data"/>
            </define>
            <define name="reg.external-sync.sync.attlist">
                <empty/>
            </define>
            <define name="reg.command-alias.elem">
                <element name="command-alias">
                    <a:documentation>Defines an alternate name for an existing command. All information about
the new command comes from the existing one.</a:documentation>
                    <ref name="reg.command-alias.contents"/>
                </element>
            </define>
            <define name="reg.command-alias.contents">
                <ref name="reg.command-alias.attlist"/>
            </define>
            <define name="reg.command-alias.attlist">
                <ref name="reg.named.ident.model"/>
                <ref name="reg.command-alias.target.attrib"/>
            </define>
        </div>
        <div>
            <a:documentation>Features and Extensions</a:documentation>
            <define name="reg.features.elem">
                <element name="features">
                    <ref name="reg.features.contents"/>
                </element>
            </define>
            <define name="reg.features.contents">
                <ref name="reg.features.attlist"/>
                <oneOrMore>
                    <ref name="reg.feature.elem"/>
                </oneOrMore>
            </define>
            <define name="reg.features.attlist">
                <empty/>
            </define>
            <define name="reg.feature.elem">
                <element name="feature">
                    <a:documentation>Defines the base API for a Vulkan specification.
Represents a specific major/minor version of Vulkan.</a:documentation>
                    <ref name="reg.feature.contents"/>
                </element>
            </define>
            <define name="reg.feature.contents">
                <ref name="reg.feature.attlist"/>
                <oneOrMore>
                    <ref name="reg.feature.specification.model"/>
                </oneOrMore>
            </define>
            <define name="reg.feature.attlist">
                <ref name="reg.api.name.attrib"/>
                <optional>
                    <ref name="reg.notation.attrib"/>
                </optional>
                <ref name="reg.feature.api.attrib"/>
                <ref name="reg.feature.version.attrib"/>
                <optional>
                    <ref name="reg.feature.define.attrib"/>
                </optional>
            </define>
            <define name="reg.feature.specification.model">
                <choice>
                    <ref name="reg.feature.require.elem"/>
                    <ref name="reg.feature.remove.elem"/>
                </choice>
            </define>
            <define name="reg.feature.require.elem">
                <element name="require">
                    <a:documentation>Definitions that are exposed by the specification.</a:documentation>
                    <ref name="reg.feature.require.contents"/>
                </element>
            </define>
            <define name="reg.feature.require.contents">
                <ref name="reg.feature.require.attlist"/>
                <oneOrMore>
                    <ref name="reg.feature.reference.model"/>
                </oneOrMore>
                <optional>
                    <ref name="reg.feature.validity.elem"/>
                </optional>
            </define>
            <define name="reg.feature.require.attlist">
                <optional>
                    <ref name="reg.feature.profile.attrib"/>
                </optional>
                <optional>
                    <ref name="reg.notation.attrib"/>
                </optional>
            </define>
            <define name="reg.feature.reference.model">
                <choice>
                    <ref name="reg.feature.defref.elem"/>
                    <ref name="reg.feature.commandref.elem"/>
                    <ref name="reg.feature.enumref.elem"/>
                </choice>
            </define>
            <define name="reg.feature.defref.elem">
                <element name="defref">
                    <a:documentation>Reference to a named `definitions` child.</a:documentation>
                    <ref name="reg.feature.defref.contents"/>
                </element>
            </define>
            <define name="reg.feature.defref.contents">
                <ref name="reg.feature.defref.attlist"/>
            </define>
            <define name="reg.feature.defref.attlist">
                <ref name="reg.named.ident.model"/>
            </define>
            <define name="reg.feature.commandref.elem">
                <element name="commandref">
                    <a:documentation>Reference to a named `commands` child.</a:documentation>
                    <ref name="reg.feature.commandref.contents"/>
                </element>
            </define>
            <define name="reg.feature.commandref.contents">
                <ref name="reg.feature.commandref.attlist"/>
            </define>
            <define name="reg.feature.commandref.attlist">
                <ref name="reg.named.ident.model"/>
            </define>
            <define name="reg.feature.enumref.elem">
                <element name="enumref">
                    <a:documentation>References a specific enumerator or constant.</a:documentation>
                    <ref name="reg.feature.enumref.contents"/>
                </element>
            </define>
            <define name="reg.feature.enumref.contents">
                <ref name="reg.feature.enumref.attlist"/>
            </define>
            <define name="reg.feature.enumref.attlist">
                <ref name="reg.named.ident.model"/>
            </define>
            <define name="reg.feature.validity.elem">
                <element name="validity">
                    <a:documentation>Provides additional validity checks when this API/extension is active.</a:documentation>
                    <ref name="reg.feature.validity.contents"/>
                </element>
            </define>
            <define name="reg.feature.validity.contents">
                <ref name="reg.feature.validity.attlist"/>
                <oneOrMore>
                    <ref name="reg.feature.usage.elem"/>
                </oneOrMore>
            </define>
            <define name="reg.feature.validity.attlist">
                <empty/>
            </define>
            <define name="reg.feature.usage.elem">
                <element name="usage">
                    <a:documentation>A single usage validity check.</a:documentation>
                    <ref name="reg.feature.usage.contents"/>
                </element>
            </define>
            <define name="reg.feature.usage.contents">
                <ref name="reg.feature.usage.attlist"/>
                <ref name="reg.validity.usage.contents"/>
            </define>
            <define name="reg.feature.usage.attlist">
                <choice>
                    <ref name="reg.feature.usage.struct.attrib"/>
                    <ref name="reg.feature.usage.command.attrib"/>
                </choice>
            </define>
            <define name="reg.feature.remove.elem">
                <element name="remove">
                    <a:documentation>Definitions which are *not* to be exposed by the specification.</a:documentation>
                    <ref name="reg.feature.remove.contents"/>
                </element>
            </define>
            <define name="reg.feature.remove.contents">
                <a:documentation>Uses same content model as `require`.</a:documentation>
                <ref name="reg.feature.remove.attlist"/>
                <ref name="reg.feature.require.contents"/>
            </define>
            <define name="reg.feature.remove.attlist">
                <empty/>
            </define>
            <define name="reg.extensions.elem">
                <element name="extensions">
                    <ref name="reg.extensions.contents"/>
                </element>
            </define>
            <define name="reg.extensions.contents">
                <ref name="reg.extensions.attlist"/>
                <oneOrMore>
                    <ref name="reg.extension.elem"/>
                </oneOrMore>
            </define>
            <define name="reg.extensions.attlist">
                <empty/>
            </define>
            <define name="reg.extension.elem">
                <element name="extension">
                    <a:documentation>Specifies the types exposed/forbidden by an extension.</a:documentation>
                    <ref name="reg.extension.contents"/>
                </element>
            </define>
            <define name="reg.extension.contents">
                <ref name="reg.extension.attlist"/>
                <oneOrMore>
                    <ref name="reg.extension.specification.model"/>
                </oneOrMore>
            </define>
            <define name="reg.extension.attlist">
                <ref name="reg.named.ident.model"/>
                <ref name="reg.extension.number.attrib"/>
                <ref name="reg.extension.api.model"/>
                <optional>
                    <ref name="reg.feature.define.attrib"/>
                </optional>
                <optional>
                    <ref name="reg.extension.requires.attrib"/>
                </optional>
                <optional>
                    <ref name="reg.extension.author.attrib"/>
                </optional>
                <optional>
                    <ref name="reg.extension.contact.attrib"/>
                </optional>
            </define>
            <define name="reg.extension.api.model">
                <a:documentation>`type` should not be optional. Only optional now due to oddities in the API.</a:documentation>
                <choice>
                    <ref name="reg.extension.disabled.attrib"/>
                    <group>
                        <ref name="reg.extension.match-api.attrib"/>
                        <optional>
                            <ref name="reg.extension.type.attrib"/>
                        </optional>
                    </group>
                </choice>
            </define>
            <define name="reg.extension.specification.model">
                <choice>
                    <ref name="reg.extension.require.elem"/>
                    <ref name="reg.extension.remove.elem"/>
                </choice>
            </define>
            <define name="reg.extension.require.elem">
                <element name="require">
                    <a:documentation>Exactly like the feature version, but with an optional `api` tag.</a:documentation>
                    <ref name="reg.extension.require.contents"/>
                </element>
            </define>
            <define name="reg.extension.require.contents">
                <ref name="reg.extension.require.attlist"/>
                <ref name="reg.feature.require.attlist"/>
                <oneOrMore>
                    <ref name="reg.extension.definition.model"/>
                </oneOrMore>
                <optional>
                    <ref name="reg.feature.validity.elem"/>
                </optional>
            </define>
            <define name="reg.extension.definition.model">
                <choice>
                    <ref name="reg.feature.defref.elem"/>
                    <ref name="reg.feature.commandref.elem"/>
                    <ref name="reg.feature.enumref.elem"/>
                    <ref name="reg.extension.constant.elem"/>
                    <ref name="reg.extension.enum.elem"/>
                </choice>
            </define>
            <define name="reg.extension.constant.elem">
                <element name="constant">
                    <a:documentation>Defines a constant exported by an extension.
These are not enumerators.</a:documentation>
                    <ref name="reg.extension.constant.contents"/>
                </element>
            </define>
            <define name="reg.extension.constant.contents">
                <ref name="reg.extension.constant.attlist"/>
            </define>
            <define name="reg.extension.constant.attlist">
                <ref name="reg.named.ident.model"/>
                <ref name="reg.extension.constant.value.model"/>
            </define>
            <define name="reg.extension.constant.value.model">
                <choice>
                    <ref name="reg.extension.constant.string.attrib">
                        <a:documentation>A string literal, for a string constant.</a:documentation>
                    </ref>
                    <ref name="reg.extension.constant.enumref.attrib">
                        <a:documentation>A reference to an existing enumerator or constant.</a:documentation>
                    </ref>
                    <ref name="reg.enum.value.model">
                        <a:documentation>Anything an enumerator/constant can handle.</a:documentation>
                    </ref>
                </choice>
            </define>
            <define name="reg.extension.enum.elem">
                <element name="enum">
                    <a:documentation>Declares a new enumerator that is added to an existing enumerator.</a:documentation>
                    <ref name="reg.extension.enum.contents"/>
                </element>
            </define>
            <define name="reg.extension.enum.contents">
                <ref name="reg.extension.enum.attlist"/>
            </define>
            <define name="reg.extension.enum.attlist">
                <ref name="reg.named.ident.model"/>
                <ref name="reg.extension.enum.extends.attrib"/>
                <ref name="reg.extension.enum.data.model"/>
            </define>
            <define name="reg.extension.enum.data.model">
                <choice>
                    <ref name="reg.enum.value.model"/>
                    <ref name="reg.extension.enum.relative.model"/>
                </choice>
            </define>
            <define name="reg.extension.enum.relative.model">
                <ref name="reg.extension.enum.offset.attrib"/>
                <optional>
                    <ref name="reg.extension.enum.negate.attrib"/>
                </optional>
            </define>
            <define name="reg.extension.require.attlist">
                <optional>
                    <ref name="reg.extension.api.attrib"/>
                </optional>
            </define>
            <define name="reg.extension.remove.elem">
                <element name="remove">
                    <a:documentation>Exactly like the feature version, but with an optional `api` tag.</a:documentation>
                    <ref name="reg.extension.remove.contents"/>
                </element>
            </define>
            <define name="reg.extension.remove.contents">
                <ref name="reg.extension.remove.attlist"/>
                <ref name="reg.feature.require.attlist"/>
                <oneOrMore>
                    <ref name="reg.extension.definition.model"/>
                </oneOrMore>
                <optional>
                    <ref name="reg.feature.validity.elem"/>
                </optional>
            </define>
            <define name="reg.extension.remove.attlist">
                <optional>
                    <ref name="reg.extension.api.attrib"/>
                </optional>
            </define>
        </div>
    </div>
    <div>
        <a:documentation>Attribute definitions</a:documentation>
        <define name="reg.notation.attrib">
            <attribute name="notation">
                <a:documentation>A textual notation regarding a particular element </a:documentation>
            </attribute>
        </define>
        <define name="reg.any.name.attrib">
            <attribute name="name">
                <a:documentation>String name for an element. Can contain any text.</a:documentation>
            </attribute>
        </define>
        <define name="reg.api.name.attrib">
            <attribute name="name">
                <a:documentation>String name for a definition that is part of the Vulkan API.
It *must* be a valid C/C++ identifier.</a:documentation>
                <ref name="reg.identifier.data"/>
            </attribute>
        </define>
        <define name="reg.vendorid.id.attrib">
            <attribute name="id">
                <a:documentation>Hexadecimal integer identifier for a vendor.
TODO: make this actual hex.</a:documentation>
            </attribute>
        </define>
        <define name="reg.tag.author.attrib">
            <attribute name="author">
                <a:documentation>Author name, usually a company or project</a:documentation>
            </attribute>
        </define>
        <define name="reg.tag.contact.attrib">
            <attribute name="contact">
                <a:documentation>Name and contact information for the person responsible for the tag</a:documentation>
            </attribute>
        </define>
        <define name="reg.include.style.attrib">
            <attribute name="style">
                <a:documentation>Specifies whether to use "" or &lt;&gt; around the include name.</a:documentation>
                <choice>
                    <value>quote</value>
                    <value>bracket</value>
                </choice>
            </attribute>
        </define>
        <define name="reg.include.need-ext.attrib">
            <attribute name="need-ext" a:default-value="false">
                <a:documentation>This specifies whether the processor needs to append a `.h` extension to the include name.
This is only necessary for the special case of `vk_platform`, because the `.h` is
not included in the name. In all other cases, it is.</a:documentation>
                <ref name="reg.boolean.data"/>
            </attribute>
        </define>
        <define name="reg.typedef.basetype.attrib">
            <attribute name="basetype">
                <a:documentation>Specifies the original typename for the typedef.
This name should reference an existing definition.</a:documentation>
                <ref name="reg.identifier.data"/>
            </attribute>
        </define>
        <define name="reg.reference.include.attrib">
            <attribute name="include">
                <a:documentation>Specifies the include file that produces the name.
This text should specify the name of an existing definition of
type `include`.</a:documentation>
            </attribute>
        </define>
        <define name="reg.bitmask.enumref.attrib">
            <attribute name="enumref">
                <a:documentation>Specifies the name of an enumerator that the bitmask gets its bits from.</a:documentation>
                <ref name="reg.identifier.data"/>
            </attribute>
        </define>
        <define name="reg.define.disabled.attrib">
            <attribute name="disabled" a:default-value="false">
                <a:documentation>If "true", then the processing system should add comments to each line of the 
#define.
That is, the #define exists, but has been commented out for some reason.</a:documentation>
                <ref name="reg.boolean.data"/>
            </attribute>
        </define>
        <define name="reg.define.replace.attrib">
            <attribute name="replace" a:default-value="false">
                <a:documentation>If "true", then the processor should not attempt to generate the #define
statement at all. The entire c-expression will include the #define
as well as the typename of the define.
It is useful for very complex #defines.</a:documentation>
                <ref name="reg.boolean.data"/>
            </attribute>
        </define>
        <define name="reg.define.value.attrib">
            <attribute name="value">
                <a:documentation>A #define's value which represents something that is generally language neutral.
A decimal number or string literal, for example.</a:documentation>
            </attribute>
        </define>
        <define name="reg.handle.parent.attrib">
            <attribute name="parent">
                <a:documentation>The name(s) of a handle object that is the parent of this handle.</a:documentation>
                <ref name="reg.csident.data"/>
            </attribute>
        </define>
        <define name="reg.handle.type.attrib">
            <attribute name="type">
                <a:documentation>Whether the handle is dispatchable or not.</a:documentation>
                <choice>
                    <value>dispatch</value>
                    <value>nodispatch</value>
                </choice>
            </attribute>
        </define>
        <define name="reg.struct.is-return.attrib">
            <attribute name="is-return" a:default-value="false">
                <a:documentation>When set to `true`, the struct is used only as a return value by the Vulkan API.</a:documentation>
                <ref name="reg.boolean.data"/>
            </attribute>
        </define>
        <define name="reg.type.basetype.attrib">
            <attribute name="basetype">
                <a:documentation>The fundamental typename of the variable. This names a definition.</a:documentation>
                <ref name="reg.identifier.data"/>
            </attribute>
        </define>
        <define name="reg.type.const.attrib">
            <attribute name="const" a:default-value="false">
                <a:documentation>If `true`, then the variable's base type is constant. If the type is
a pointer or array, the `const` refers to the base type. So `const T *` rather
than `T *const`.</a:documentation>
                <ref name="reg.boolean.data"/>
            </attribute>
        </define>
        <define name="reg.type.struct.attrib">
            <attribute name="struct" a:default-value="false">
                <a:documentation>If `true`, then the basetype name needs to be preceeded by the C keyword
"struct" when interfacing with C.</a:documentation>
                <ref name="reg.boolean.data"/>
            </attribute>
        </define>
        <define name="reg.type.reference.attrib">
            <attribute name="reference">
                <a:documentation>If present, then the variable is a pointer of some sort.
This does not guarantee that variable is an *array*.</a:documentation>
                <choice>
                    <value>pointer</value>
                    <a:documentation>Type is a pointer</a:documentation>
                    <value>pointer-pointer</value>
                    <a:documentation>Type is a pointer-to-a-pointer, perhaps a dynamic array of pointers</a:documentation>
                    <value>pointer-const-pointer</value>
                    <a:documentation>Type is a `* const *`. A dynamic array of const pointers to (possibly const) basetype.</a:documentation>
                </choice>
            </attribute>
        </define>
        <define name="reg.type.static.array.attrib">
            <attribute name="array">
                <a:documentation>The variable is a compile-time sized array.
This will be rendered out with `[size]` in C/C++, where `size` is the
associated `size` attribute</a:documentation>
                <value>static</value>
            </attribute>
        </define>
        <define name="reg.type.static.array.size.attrib">
            <attribute name="size">
                <a:documentation>The length of a static array variable, specified as an integer literal
Must be present on all static arrays.</a:documentation>
                <data type="positiveInteger"/>
            </attribute>
        </define>
        <define name="reg.type.static.array.size-enumref.attrib">
            <attribute name="size-enumref">
                <a:documentation>The length of a static array variable, specified as an enumerator reference.</a:documentation>
                <ref name="reg.identifier.data"/>
            </attribute>
        </define>
        <define name="reg.type.dynamic.array.attrib">
            <attribute name="array">
                <a:documentation>The variable is a runtime sized array.
This will only be applied to pointer types. It spells out the difference
between a pointer to a single object and a pointer as a dynamic array.</a:documentation>
                <value>dynamic</value>
            </attribute>
        </define>
        <define name="reg.type.dynamic.array.size.attrib">
            <attribute name="size">
                <a:documentation>The name of a construct, usually a member of the same struct or parameter to the same
function that provides the size of a dynamic array.
May also be a `latexmath:` expression, which may internally reference the
name of a struct/parameter.
Optional. If not present, then the dynamic array is either null-terminated or has no
specific size.
If the construct is a pointer-pointer, then this only specifies the size of the
outer array.</a:documentation>
            </attribute>
        </define>
        <define name="reg.type.dynamic.array.null-terminate.attrib">
            <attribute name="null-terminate" a:default-value="false">
                <a:documentation>If `true`, then a string variable (some form of pointer with the type `char`)
is null-terminated. If the type is a `pointer-pointer` or a `pointer-const-pointer`,
then the null-terminator refers only to the innermost string pointers.</a:documentation>
                <ref name="reg.boolean.data"/>
            </attribute>
        </define>
        <define name="reg.variable.optional.attrib">
            <attribute name="optional" a:default-value="false">
                <a:documentation>A sequence of comma-separated boolean values.
Each boolean value represents a particular indirection, starting from the outermost
pointer. The true/false represents whether that indirection is optional.
For example, if an integer pointer type has `optional` set to `false,true`,
this means that the pointer is required, but the integer value may be zero.</a:documentation>
                <ref name="reg.csboolean.data"/>
            </attribute>
        </define>
        <define name="reg.variable.auto-validity.attrib">
            <attribute name="auto-validity" a:default-value="true">
                <a:documentation>If set to "false", then auto-validation for the variable should not be generated.</a:documentation>
                <ref name="reg.boolean.data"/>
            </attribute>
        </define>
        <define name="reg.variable.sync.attrib">
            <attribute name="sync">
                <a:documentation>If present, will be either "true" or an expression that more explicitly
describes how it must externally sync.
If absent, then external synchronization is not necessary.</a:documentation>
                <choice>
                    <value>true</value>
                    <text/>
                </choice>
            </attribute>
        </define>
        <define name="reg.variable.inout.attrib">
            <attribute name="inout" a:default-value="in">
                <a:documentation>Determines whether the variable is used as an input, output, or both.</a:documentation>
                <choice>
                    <value>in</value>
                    <value>out</value>
                    <value>inout</value>
                </choice>
            </attribute>
        </define>
        <define name="reg.struct.member.extension-structs.attrib">
            <attribute name="extension-structs">
                <a:documentation>Comma-separated list of structs that this member can be used with.</a:documentation>
                <ref name="reg.csident.data"/>
            </attribute>
        </define>
        <define name="reg.struct.member.type-enums.attrib">
            <attribute name="type-enums">
                <a:documentation>Comma-separated list of enumerators that this member can be given.</a:documentation>
                <ref name="reg.csident.data"/>
            </attribute>
        </define>
        <define name="reg.enum.number.attrib">
            <attribute name="number">
                <a:documentation>An enumerator/constant value which is just an integer number.</a:documentation>
                <data type="integer"/>
            </attribute>
        </define>
        <define name="reg.enum.hex.attrib">
            <attribute name="hex">
                <a:documentation>Specifies a hexadecimal integer that represents all the bits set by this mask.
Not prefixed with "0x".</a:documentation>
                <ref name="reg.hexadecimal.data"/>
            </attribute>
        </define>
        <define name="reg.enum.bitpos.attrib">
            <attribute name="bitpos">
                <a:documentation>Specifies the index of the bit to set for this field.</a:documentation>
                <data type="nonNegativeInteger"/>
            </attribute>
        </define>
        <define name="reg.enum.c-expression.attrib">
            <attribute name="c-expression">
                <a:documentation>A C-expression defining an enumerator/constant's value.
These could be a floating-point number or a more complex expression
such as (~0LL) or somesuch</a:documentation>
            </attribute>
        </define>
        <define name="reg.enum.purpose.attrib">
            <attribute name="purpose">
                <a:documentation>Identifies a special meaning behind the enumeration.
"bitmask" means that the enumerators are either specific bits or
combinations of bits. There should be a `bitmask` definition
attribute which uses this enumeration as the source for its enums.</a:documentation>
                <value>bitmask</value>
            </attribute>
        </define>
        <define name="reg.enum.range-start.attrib">
            <attribute name="range-start">
                <a:documentation>Beginning of an enumerator value range</a:documentation>
                <data type="integer"/>
            </attribute>
        </define>
        <define name="reg.enum.range-end.attrib">
            <attribute name="range-end">
                <a:documentation>End fo an enumerator value range</a:documentation>
                <data type="integer"/>
            </attribute>
        </define>
        <define name="reg.command.successcodes.attrib">
            <attribute name="successcodes">
                <a:documentation>Specifies the return codes that represent successful function execution.
When not specified, then the command doesn't return `VkResult`</a:documentation>
                <ref name="reg.csident.data"/>
            </attribute>
        </define>
        <define name="reg.command.errorcodes.attrib">
            <attribute name="errorcodes">
                <a:documentation>Specifies the return codes that represent error conditions.
When not specified, either the command doesn't return `VkResult` or it cannot "fail".</a:documentation>
                <ref name="reg.csident.data"/>
            </attribute>
        </define>
        <define name="reg.command.renderpass.attrib">
            <attribute name="renderpass">
                <a:documentation>Specifies how the command may be called, relative to render pass instance scopes.
When not specified, the command does not care about render pass scoping,
or the command isn't a vkCmd command.</a:documentation>
                <choice>
                    <value>inside</value>
                    <value>outside</value>
                    <value>both</value>
                </choice>
            </attribute>
        </define>
        <define name="reg.command.cmdbufferlevel.attrib">
            <attribute name="cmdbufferlevel">
                <a:documentation>Specifies the level of command buffer that the command can be used with.
When not specified, the command does not go into a command buffer.</a:documentation>
                <choice>
                    <value>primary</value>
                    <value>secondary</value>
                    <value>primary,secondary</value>
                </choice>
            </attribute>
        </define>
        <define name="reg.command.queues.attrib">
            <attribute name="queues">
                <a:documentation>Comma-separated list of queues that support this operation.
When not specified, the function cannot be used in a queue.</a:documentation>
                <ref name="reg.csident.data"/>
            </attribute>
        </define>
        <define name="reg.command-alias.target.attrib">
            <attribute name="target">
                <a:documentation>Specifies the target name of the alias. This may be another alias,
so long as the eventual chain of targets leads to an actual command.</a:documentation>
                <ref name="reg.identifier.data"/>
            </attribute>
        </define>
        <define name="reg.feature.api.attrib">
            <attribute name="api">
                <a:documentation>The name of the API that a feature defines.</a:documentation>
            </attribute>
        </define>
        <define name="reg.feature.version.attrib">
            <attribute name="version">
                <a:documentation>Version number for the feature.</a:documentation>
                <data type="float"/>
            </attribute>
        </define>
        <define name="reg.feature.define.attrib">
            <attribute name="define">
                <a:documentation>When generating C-style information, use this as the #define wrapper
around this feature.</a:documentation>
                <ref name="reg.identifier.data"/>
            </attribute>
        </define>
        <define name="reg.feature.profile.attrib">
            <attribute name="profile">
                <a:documentation>The name of the API profile which this specialization element
is associated. All specified requirements/exclusions apply
only to that profile.</a:documentation>
            </attribute>
        </define>
        <define name="reg.feature.usage.struct.attrib">
            <attribute name="struct">
                <a:documentation>Specifies the name of a &lt;struct&gt; which this `usage` statement extends.</a:documentation>
                <ref name="reg.identifier.data"/>
            </attribute>
        </define>
        <define name="reg.feature.usage.command.attrib">
            <attribute name="command">
                <a:documentation>Specifies the name of a &lt;command&gt; which this `usage` statement extends.</a:documentation>
                <ref name="reg.identifier.data"/>
            </attribute>
        </define>
        <define name="reg.extension.number.attrib">
            <attribute name="number">
                <a:documentation>The extension's registration number.
Used to compute the offsets for enumerators and the like.</a:documentation>
                <data type="positiveInteger"/>
            </attribute>
        </define>
        <define name="reg.extension.disabled.attrib">
            <attribute name="disabled">
                <a:documentation>Specifies that the extension is disabled. If it is not present, then the extension is
enabled.</a:documentation>
                <value>true</value>
            </attribute>
        </define>
        <define name="reg.extension.match-api.attrib">
            <attribute name="match-api">
                <a:documentation>A regex used to match an `api` tag on a `feature` element.
If it matches, then the extension can be used with that API.</a:documentation>
            </attribute>
        </define>
        <define name="reg.extension.type.attrib">
            <attribute name="type">
                <a:documentation>Specifies the kind of extension: instance or device.</a:documentation>
                <choice>
                    <value>instance</value>
                    <value>device</value>
                </choice>
            </attribute>
        </define>
        <define name="reg.extension.requires.attrib">
            <attribute name="requires">
                <a:documentation>A comma-separated list of identifiers, specifying
extensions this extension requires in order to function.</a:documentation>
                <ref name="reg.csident.data"/>
            </attribute>
        </define>
        <define name="reg.extension.author.attrib">
            <attribute name="author">
                <a:documentation>The name of the author of an extension, typically a company.
When absent, can be gleamed by using the `name` and parsing out the
author part of the name, then finding the corresponding `tag` element.</a:documentation>
            </attribute>
        </define>
        <define name="reg.extension.contact.attrib">
            <attribute name="contact">
                <a:documentation>The name and contact info for the person who is responsible for
the extension. Can be inferred in the same way as `author`.</a:documentation>
            </attribute>
        </define>
        <define name="reg.extension.api.attrib">
            <attribute name="api">
                <a:documentation>Specifies that the extensions or removals only apply to that specific
API being generated. If not present, it applies to all APIs.</a:documentation>
            </attribute>
        </define>
        <define name="reg.extension.constant.string.attrib">
            <attribute name="string">
                <a:documentation>An arbitrary string constant. The string here is not contained in quotes.
So you should add your own.</a:documentation>
            </attribute>
        </define>
        <define name="reg.extension.constant.enumref.attrib">
            <attribute name="enumref">
                <a:documentation>Specifies a constant who's value comes from an enum
or another existing constant.</a:documentation>
                <ref name="reg.identifier.data"/>
            </attribute>
        </define>
        <define name="reg.extension.enum.extends.attrib">
            <attribute name="extends">
                <a:documentation>The name of an `enumeration` to be extended.</a:documentation>
                <ref name="reg.identifier.data"/>
            </attribute>
        </define>
        <define name="reg.extension.enum.offset.attrib">
            <attribute name="offset">
                <a:documentation>Compute the enum's value based on an integer offset.</a:documentation>
                <data type="nonNegativeInteger"/>
            </attribute>
        </define>
        <define name="reg.extension.enum.negate.attrib">
            <attribute name="negate" a:default-value="false">
                <a:documentation>If true, the offset's value should be negated.
Primarily for error codes.</a:documentation>
                <ref name="reg.boolean.data"/>
            </attribute>
        </define>
    </div>
    <div>
        <a:documentation>Data types</a:documentation>
        <define name="reg.spec-language.data">
            <a:documentation>Represents text formatted in accord with the Vulkan standard.
Such text can be copied and pasted into the spec, using the spec's
format.</a:documentation>
            <text/>
        </define>
        <define name="reg.identifier.data">
            <a:documentation>Should be a valid C/C++ identifier.</a:documentation>
            <data type="string">
                <param name="pattern">[A-Za-z_][A-Za-z0-9_]*</param>
            </data>
        </define>
        <define name="reg.csident.data">
            <a:documentation>Comma-separated identifiers values.
Can be empty.</a:documentation>
            <data type="string">
                <param name="pattern">([A-Za-z_][A-Za-z0-9_]*(,([A-Za-z_][A-Za-z0-9_]*))*)?</param>
            </data>
        </define>
        <define name="reg.hexadecimal.data">
            <a:documentation>Recognize a hexadecimal number.
Not prefixed with "0x"</a:documentation>
            <data type="string">
                <param name="pattern">[A-Fa-f0-9]+</param>
            </data>
        </define>
        <define name="reg.boolean.data">
            <a:documentation>XSD's boolean type includes things other than "true" and "false",
so we do it manually.</a:documentation>
            <choice>
                <value>true</value>
                <value>false</value>
            </choice>
        </define>
        <define name="reg.csboolean.data">
            <a:documentation>Comma-separated boolean values.</a:documentation>
            <data type="string">
                <param name="pattern">(true|false)(,(true|false))*</param>
            </data>
        </define>
    </div>
    <div>
        <a:documentation>Supplementary elements and definitions.</a:documentation>
        <define name="INCOMPLETE">
            <empty/>
        </define>
    </div>
</grammar>
