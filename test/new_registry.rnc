
datatypes xsd = "http://www.w3.org/2001/XMLSchema-datatypes"
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"


## All elements and primary content models
div
{
    start = reg.root-element.model
    
    reg.root-element.model =
        reg.registry.elem
    
    reg.registry.elem =
        ##Base element. Contains all of the information for Vulkan.
        element registry { reg.registry.contents }
       
    reg.registry.contents =
        reg.registry.attlist,
        reg.notation.elem*,
        reg.vendorids.elem?,
        reg.notation.elem*,
        reg.tags.elem?,
        reg.notation.elem*,
        reg.definitions.elem,
        reg.notation.elem*,
        reg.constants.elem?,
        reg.notation.elem*,
        reg.enums.elem?,
        reg.notation.elem*,
        reg.commands.elem,
        reg.notation.elem*,
        reg.features.elem,
        reg.notation.elem*,
        reg.extensions.elem?,
        reg.notation.elem*
    
    reg.registry.attlist = empty

    reg.notation.elem =
        ## A textual annotation. These are usually intended to be reproduced verbatim
        ## in some way in any generated files.
        element notation { reg.notation.contents }
    
    reg.notation.contents =
        reg.notation.attlist,
        text
    
    reg.notation.attlist = empty
        
    ## Attributes for (almost) any element that represents an identifier in Vulkan.
    ## All such identifiers can have a notation.
    reg.named.ident.model =
        reg.api.name.attrib,
        reg.notation.attrib?

    ## Front matter: vendorids and tags.
    div
    {
        reg.vendorids.elem =
            ## The list of all vendorid elements.
            element vendorids { reg.vendorids.contents }
            
        reg.vendorids.contents =
            reg.vendorids.attlist,
            reg.vendorid.elem+
        
        reg.vendorids.attlist =
            reg.notation.attrib?
        
        reg.vendorid.elem =
            ## List of identifiers for vendors.
            element vendorid { reg.vendorid.contents }
        
        reg.vendorid.contents =
            reg.vendorid.attlist
            
        reg.vendorid.attlist =
            reg.any.name.attrib,
            reg.vendorid.id.attrib,
            reg.notation.attrib?

        reg.tags.elem =
            ## List of authors
            element tags { reg.tags.contents }
            
        reg.tags.contents =
            reg.tags.attlist,
            reg.tag.elem+
            
        reg.tags.attlist =
            reg.notation.attrib?
        
        reg.tag.elem =
            ## A single author for Vulkan
            element tag { reg.tag.contents }
            
        reg.tag.contents =
            reg.tag.attlist
            
        reg.tag.attlist =
            reg.any.name.attrib,
            reg.tag.author.attrib,
            reg.tag.contact.attrib,
            reg.notation.attrib?
    }
    
    ## Definition elements.
    div
    {
        reg.definitions.elem =
            ## List of all definitions used by Vulkan 
            element definitions { reg.definitions.contents }
            
        reg.definitions.contents =
            reg.definitions.attlist,
            reg.definitions.model+

        reg.definitions.attlist =
            reg.notation.attrib?
        
        reg.definitions.model =
            reg.notation.elem |
            reg.include.elem | 
            ## Formerly `basetype`
            reg.typedef.elem | 
            ## Formerly no category. Simply specifies the existence of a named type that
            ## usually is brought in by a `requires` attribute.
            reg.reference.elem |   
            reg.def.bitmask.elem |
            reg.struct.elem |
            reg.union.elem |
            reg.define.elem |
            reg.handle.elem |
            reg.def.enumeration.elem |
            reg.funcptr.elem
        
        reg.include.elem =
            ## Definition that represents a file being included, which is named.
            ## The `name` attribute does double-duty, in that it also includes text.
            element include { reg.include.contents }
            
        reg.include.contents =
            reg.include.attlist
            
        reg.include.attlist =
            ## An include's `name` is a full pathname, not just an C/C++ identifier.
            reg.any.name.attrib,
            reg.notation.attrib?,
            reg.include.style.attrib,
            reg.include.need-ext.attrib?
        
        reg.typedef.elem =
            ## Definition that defines a new name for an existing type. 
            element typedef { reg.typedef.contents }
            
        reg.typedef.contents =
            reg.typedef.attlist,
            reg.notation.elem*
            
        reg.typedef.attlist =
            reg.named.ident.model,
            reg.typedef.basetype.attrib
            
        reg.reference.elem =
            ## Definition that references a type that potentially comes from an include file.
            element reference { reg.reference.contents }
        
        reg.reference.contents =
            reg.reference.attlist,
            reg.notation.elem*
            
        reg.reference.attlist =
            ##Standard types like `int` do not need the `include` file.
            reg.named.ident.model,
            reg.reference.include.attrib?
            
        reg.def.bitmask.elem =
            ## Definition that specifies a bitmask, using a particular existing type.
            ## Contents are the same as `typedef`.
            ## The possible bits can be defined by a specific, referenced enumeration.
            element bitmask { reg.def.bitmask.contents }
            
        reg.def.bitmask.contents =
            reg.def.bitmask.attlist,
            reg.notation.elem*
                
        reg.def.bitmask.attlist =
            reg.typedef.attlist,
            reg.bitmask.enumref.attrib?
            
        reg.define.elem =
            ## Definition that represents a C #define statement.
            element define { reg.define.contents }
            
        ## The 3 forms of defines:
        ## #define name C-expression
        ## #define name(params) C-expression
        ## C-expression
        ##
        ## In all cases, C-expression should be verbatim copied. The question is whether the text
        ## contains the actual "#define" internally or not.
        ## Defines can also reference other definitions.    
        reg.define.contents =
            reg.define.attlist,
            reg.define.comment.elem?,
            reg.define.model
            
        reg.define.attlist =
            reg.named.ident.model,
            reg.define.disabled.attrib?
            
        reg.define.comment.elem =
            ## Specifies a possibly multi-line in-language comment which is expected to be
            ## placed near the element in which `comment` appears.
            element comment {text}
        
        reg.define.model = 
            (reg.define.value.attrib | reg.define.complex.model)
    
        reg.define.complex.model =
            reg.define.replace.attrib?,
            reg.define.defref.elem*,
            reg.define.param.elem*,
            reg.c-expression.elem
        
        reg.define.defref.elem =
            ## Specifies a definition that is referenced in the C-expression.
            element defref { reg.identifier.data }
            
        reg.define.param.elem =
            ## The name of a #define's parameter.
            element param { reg.identifier.data }
        
        reg.c-expression.elem =
            ## Text that is intended to be used verbatim in C or C++ implementations.
            ## If the `replace` attribute is not `true`, then the processor should
            ## generate the `#define NAME(PARAMS)` part of the define before the c-expression.
            element c-expression { text }
            
        reg.handle.elem =
            ## Creates a definition for a handle.
            element handle { reg.handle.contents }
            
        reg.handle.contents =
            reg.handle.attlist,
            reg.notation.elem*
    
        reg.handle.attlist =
            reg.named.ident.model,
            reg.handle.parent.attrib?,
            reg.handle.type.attrib
            
        reg.def.enumeration.elem =
            ## Defines the name of an enumeration.
            ## The members and base type of the enumeration are defined elsewhere.
            element enumeration { reg.def.enumeration.contents }
            
        reg.def.enumeration.contents =
            reg.def.enumeration.attlist,
            reg.notation.elem*
            
        reg.def.enumeration.attlist =
            reg.named.ident.model
    
        reg.struct.elem =
            ## Definition that represents a data structure.
            ## Contains a list of members and optional validation information.
            element struct { reg.struct.contents }
        
        reg.struct.contents =
            reg.struct.attlist,
            reg.struct.model
            
        reg.struct.attlist =
            reg.named.ident.model,
            reg.struct.is-return.attrib?,
            reg.struct.extends.attrib?

        reg.struct.model =
            (reg.notation.elem* & reg.struct.member.elem+),
            reg.validity.elem?,
            reg.notation.elem*
            
        reg.struct.member.elem =
            ## Specifies a named member of a data structure.
            element member { reg.struct.member.contents }
        
        reg.struct.member.contents =
            reg.struct.member.attlist,
            reg.struct.member.model
            
        reg.struct.member.model =
            reg.notation.elem*
    
        reg.struct.member.attlist =
            reg.named.ident.model,
            reg.typed.variable.model,
            reg.struct.member.extension-structs.attrib?,
            reg.struct.member.type-enums.attrib?
        
        ## All of the attributes that represent the type of a
        ## struct member, function parameter or return value.
        reg.type.model =
            reg.type.basetype.attrib,
            reg.type.array.model?,
            reg.type.const.attrib?,
            reg.type.struct.attrib?,
            reg.type.reference.attrib?
        
        ## Can either be a static array or a dynamic array.
        ## Which one is used changes the meaning of the `size` attribute.
        ## Static arrays must have a `size`; dynamic do not.
        reg.type.array.model =
            (reg.type.static.array.model |
            reg.type.dynamic.array.model),
            reg.type.array.c-size.attrib?
            
        ## Static arrays have `array` set to "static" and the sizing attribute.
        reg.type.static.array.model =
            reg.type.static.array.attrib,
            reg.type.static.array.size.model
            
        ## Static sizes can be integer constants or enumerator references.
        reg.type.static.array.size.model =
            reg.type.static.array.size.attrib |
            reg.type.static.array.size-enumref.attrib

        ## Dynamic arrays have `array` set to "dynamic", and may have
        ## the `null-terminate` attribute, `size` attribute, or both.
        ## If it has neither, then the size is not determinable.
        ## If it has both, then the `null-terminate` size refers to a `char*` of
        ## some form, with the `size` referring to the outer array.
        reg.type.dynamic.array.model =
            reg.type.dynamic.array.attrib,
            reg.type.dynamic.array.size.attrib?,
            reg.type.dynamic.array.null-terminate.attrib?
        
        ## Data model describing type information for a variable.
        ## Variables have a type, but they also have additional data about
        ## the purpose of the variable.
        reg.typed.variable.model =
            reg.type.model,
            reg.variable.optional.attrib?,
            reg.variable.auto-validity.attrib?,
            reg.variable.inout.attrib?,
            reg.variable.sync.attrib?

        reg.validity.elem =
            ## Defines validation text related to objects and commands.
            element validity { reg.validity.contents }
            
        reg.validity.contents =
            reg.validity.attlist,
            reg.validity.usage.elem+
        
        reg.validity.attlist = empty
        
        reg.validity.usage.elem =
            ## A specific validation rule, spelled out in documentation text.
            element usage { reg.validity.usage.contents }
            
        reg.validity.usage.contents =
            reg.validity.usage.attlist,
            reg.spec-language.data
            
        reg.validity.usage.attlist = empty
    
        reg.union.elem =
            ## Defines a union, where the object's value is only one of the members.
            element union { reg.union.contents }
            
        reg.union.contents =
            reg.union.attlist,
            reg.union.model
    
        reg.union.model =
            reg.notation.elem* &
            reg.union.member.elem+

        reg.union.attlist =
            reg.named.ident.model
        
        reg.union.member.elem =
            ## Specifies a named member of a union.
            element member { reg.union.member.contents }
            
        reg.union.member.contents =
            reg.union.member.attlist
        
        reg.union.member.attlist =
            reg.named.ident.model,
            reg.type.model

        reg.funcptr.elem =
            ## Defines a function pointer.
            element funcptr { reg.funcptr.contents }
            
        ## If it has no function parameters, then it should be rendered out for C/C++ with just
        ## "void" in the parameter list. And just "void" should not be in a `<type>` element, as it
        ## does not qualify as a parameter type.
        reg.funcptr.contents =
            reg.funcptr.attlist,
            reg.return-type.elem,
            reg.param.elem*
    
        reg.funcptr.attlist =
            reg.named.ident.model

        reg.return-type.elem =
            element return-type { reg.return-type.contents }
            
        reg.return-type.contents =
            reg.return-type.attlist
    
        reg.return-type.attlist =
            reg.type.model,
            reg.error-code.model?
        
        reg.error-code.model =
            reg.command.successcodes.attrib,
            reg.command.errorcodes.attrib

        reg.param.elem =
            element param { reg.param.contents }
        
        reg.param.contents =
            reg.param.attlist

        reg.param.attlist =
            ##Parameter names are not required for functions.
            reg.named.ident.model?,
            reg.typed.variable.model
    }
    
    ## Constants and Enumeration elements.
    div 
    {
        reg.constants.elem =
            element constants { reg.constants.contents }
            
        reg.constants.contents =
            reg.constants.attlist,
            reg.constants.model
            
        reg.constants.model =
            reg.notation.elem* &
            reg.constant.elem+
            
        reg.constants.attlist =
            reg.notation.attrib?
            
        reg.constant.elem =
            ##Contains a named constant value that is not typed to an enumeration.
            element constant { reg.constant.contents }
            
        reg.constant.contents =
            reg.constant.attlist
        
        reg.constant.attlist =
            reg.named.ident.model,
            reg.enum.value.model
        
        ##Enumerators can be decimal integers, C-expressions, bit positions, or hexadecimal bitmasks.
        reg.enum.value.model =
            ## Decimal integer
            reg.enum.number.attrib |
            ## Unsigned hexadecimal value, mainly for bitmasks.
            reg.enum.hex.attrib |
            ## Bit position, to be transformed into a number by `1 << bitpos`.
            reg.enum.bitpos.attrib |
            ## C-expression that results in a number.
            reg.enum.c-expression.attrib
        
        reg.enums.elem =
            ## Contains both enumerations and bitmasks.
            element enums { reg.enums.contents }
            
        reg.enums.contents =
            reg.enums.attlist,
            reg.enums.model
            
        reg.enums.model =
            reg.notation.elem* &
            reg.enumeration.elem+
    
        reg.enums.attlist =
            reg.notation.attrib?
            
        reg.enumeration.elem =
            element enumeration { reg.enumeration.contents }
            
        reg.enumeration.contents =
            reg.enumeration.attlist,
            ## Empty enumerations are OK; extensions could fill them.
            (reg.notation.elem* &
            reg.enumeration.enum.elem* &
            reg.enumeration.unused-range.elem*)
            
        reg.enumeration.attlist =
            reg.named.ident.model,
            reg.enum.purpose.attrib?,
            reg.enum.range.model?
            
        reg.enum.range.model =
            ##Represents a range of enumerators.
            reg.enum.range-start.attrib,
            reg.enum.range-end.attrib?
        
        reg.enumeration.enum.elem =
            element enum { reg.enumeration.enum.contents }
            
        reg.enumeration.enum.contents =
            reg.enumeration.enum.attlist
            
        reg.enumeration.enum.attlist =
            reg.named.ident.model,
            reg.enum.value.model
            
        reg.enumeration.unused-range.elem =
            element unused-range { reg.enumeration.unused-range.contents }
            
        reg.enumeration.unused-range.contents =
            reg.enumeration.unused-range.attlist
            
        reg.enumeration.unused-range.attlist =
            reg.enum.range.model
    }
    
    ## Command elements
    div
    {
        reg.commands.elem =
            ## Defines a list of Vulkan entrypoints.
            element commands { reg.commands.contents }
            
        reg.commands.contents =
            reg.commands.attlist,
            (reg.command.elem | reg.command-alias.elem)+

        reg.commands.attlist =
            reg.notation.attrib?
        
        reg.command.elem =
            ## Defines a single Vulkan entrypoint.
            element command { reg.command.contents }
            
        reg.command.contents =
            reg.command.attlist,
            reg.return-type.elem,
            reg.param.elem*,
            ( reg.command.description.elem? & reg.command.external-sync.elem? & reg.validity.elem? )
            
        reg.command.attlist =
            reg.named.ident.model,
            reg.command.renderpass.attrib?,
            reg.command.cmdbufferlevel.attrib?,
            reg.command.pipeline.attrib?,
            reg.command.queues.attrib?
            
        reg.command.description.elem =
            ## Textual description of the command... in some form?
            element description { reg.command.description.contents }
            
        reg.command.description.contents =
            reg.command.description.attlist,
            reg.spec-language.data
            
        reg.command.description.attlist = empty
            
        reg.command.external-sync.elem =
            ## Describes instances of implicit external synchronizations.
            ## These cannot be captured by the parameters themselves.
            element external-sync { reg.command.external-sync.contents }
            
        reg.command.external-sync.contents =
            reg.command.external-sync.attlist,
            reg.external-sync.sync.elem+
            
        reg.command.external-sync.attlist = empty
            
        reg.external-sync.sync.elem =
            ## A single aspect of implicit external synchronization.
            element sync { reg.external-sync.sync.contents }

        reg.external-sync.sync.contents =
            reg.external-sync.sync.attlist,
            reg.spec-language.data
            
        reg.external-sync.sync.attlist = empty
            
        reg.command-alias.elem =
            ## Defines an alternate name for an existing command. All information about
            ## the new command comes from the existing one.
            element command-alias { reg.command-alias.contents }
            
        reg.command-alias.contents =
            reg.command-alias.attlist

        reg.command-alias.attlist =
            reg.named.ident.model,
            reg.command-alias.target.attrib
    }


    ## Features and Extensions
    div
    {
        reg.features.elem =
            element features { reg.features.contents }
            
        reg.features.contents =
            reg.features.attlist,
            reg.feature.elem+
            
        reg.features.attlist = empty
    
        reg.feature.elem =
            ## Defines the base API for a Vulkan specification.
            ## Represents a specific major/minor version of Vulkan.
            element feature { reg.feature.contents }
        
        reg.feature.contents =
            reg.feature.attlist,
            reg.feature.model
            
        reg.feature.attlist =
            reg.api.name.attrib,
            reg.notation.attrib?,
            reg.feature.api.attrib,
            reg.feature.version.attrib,
            reg.feature.define.attrib?
        
        reg.feature.model =
            reg.notation.elem* &
            reg.feature.specification.model+
        
        reg.feature.specification.model =
            reg.feature.require.elem |
            reg.feature.remove.elem
        
        reg.feature.require.elem =
            ## Definitions that are exposed by the specification.
            element require { reg.feature.require.contents }
            
        reg.feature.require.contents =
            reg.feature.require.attlist,
            reg.feature.reference.model+,
            reg.feature.validity.elem?
            
        reg.feature.require.attlist =
            reg.common.require.model,
            reg.require.extension.attrib?
            
        reg.common.require.model =
            reg.feature.profile.attrib?,
            reg.notation.attrib?
        
        reg.feature.reference.model =
            reg.feature.defref.elem |
            reg.feature.commandref.elem |
            reg.feature.enumref.elem |
            reg.notation.elem
            
        reg.feature.defref.elem =
            ## Reference to a named `definitions` child.
            element defref { reg.feature.defref.contents }

        reg.feature.defref.contents =
            reg.feature.defref.attlist
        
        reg.feature.defref.attlist =
            reg.named.ident.model
            
        reg.feature.commandref.elem =
            ## Reference to a named `commands` child.
            element commandref { reg.feature.commandref.contents }
            
        reg.feature.commandref.contents =
            reg.feature.commandref.attlist
            
        reg.feature.commandref.attlist =
            reg.named.ident.model
        
        reg.feature.enumref.elem =
            ## References a specific enumerator or constant.
            element enumref { reg.feature.enumref.contents }

        reg.feature.enumref.contents =
            reg.feature.enumref.attlist
            
        reg.feature.enumref.attlist =
            reg.named.ident.model

        reg.feature.validity.elem =
            ## Provides additional validity checks when this API/extension is active.
            element validity { reg.feature.validity.contents }
        
        reg.feature.validity.contents =
            reg.feature.validity.attlist,
            reg.feature.usage.elem+
        
        reg.feature.validity.attlist = empty
        
        reg.feature.usage.elem =
            ## A single usage validity check.
            element usage { reg.feature.usage.contents }
            
        reg.feature.usage.contents =
            reg.feature.usage.attlist,
            reg.validity.usage.contents
            
        reg.feature.usage.attlist =
            reg.feature.usage.struct.attrib |
            reg.feature.usage.command.attrib 
        
        reg.feature.remove.elem =
            ## Definitions which are *not* to be exposed by the specification.
            element remove { reg.feature.remove.contents }
            
        ##Uses same content model as `require`.
        reg.feature.remove.contents =
            reg.feature.remove.attlist,
            reg.feature.require.contents
            
        reg.feature.remove.attlist = empty
        
        reg.extensions.elem =
            element extensions { reg.extensions.contents }
            
        reg.extensions.contents =
            reg.extensions.attlist,
            reg.extension.elem+
            
        reg.extensions.attlist = 
            reg.notation.attrib?
            
        reg.extension.elem =
            ## Specifies the types exposed/forbidden by an extension.
            element extension { reg.extension.contents }
        
        reg.extension.contents =
            reg.extension.attlist,
            reg.extension.model

        reg.extension.attlist =
            reg.named.ident.model,
            reg.extension.number.attrib,
            reg.extension.api.model,
            reg.feature.define.attrib?,
            reg.extension.requires.attrib?,
            reg.extension.author.attrib?,
            reg.extension.contact.attrib?
            
        ## `type` should not be optional. Only optional now due to oddities in the API.
        reg.extension.api.model =
            reg.extension.disabled.attrib |
            (reg.extension.match-api.attrib, reg.extension.type.attrib)

        reg.extension.model =
            reg.notation.elem* &
            reg.extension.specification.model+

        reg.extension.specification.model =
            reg.extension.require.elem |
            reg.extension.remove.elem
            
        reg.extension.require.elem =
            ## Exactly like the feature version, but with an optional `api` tag.
            element require { reg.extension.require.contents }
            
        reg.extension.require.contents =
            reg.extension.require.attlist,
            reg.common.require.model,
            reg.extension.require.common.model,
            reg.extension.definition.model+,
            reg.feature.validity.elem?
            
        reg.extension.require.attlist = empty
            
        reg.extension.require.common.model =
            reg.extension.api.attrib?,
            reg.require.extension.attrib?

        reg.extension.definition.model =
            reg.feature.defref.elem |
            reg.feature.commandref.elem |
            reg.feature.enumref.elem |
            reg.extension.constant.elem |
            reg.extension.enum.elem |
            reg.notation.elem

        reg.extension.constant.elem =
            ## Defines a constant exported by an extension.
            ## These are not enumerators.
            element constant { reg.extension.constant.contents }
        
        reg.extension.constant.contents =
            reg.extension.constant.attlist
        
        reg.extension.constant.attlist =
            reg.named.ident.model,
            reg.extension.constant.value.model
            
        reg.extension.constant.value.model =
            ## A string literal, for a string constant.
            reg.extension.constant.string.attrib |
            ## A reference to an existing enumerator or constant.
            reg.extension.constant.enumref.attrib |
            ## Anything an enumerator/constant can handle.
            reg.enum.value.model

        reg.extension.enum.elem =
            ## Declares a new enumerator that is added to an existing enumerator.
            element enum { reg.extension.enum.contents }
            
        reg.extension.enum.contents =
            reg.extension.enum.attlist
            
        reg.extension.enum.attlist =
            reg.named.ident.model,
            reg.extension.enum.extends.attrib,
            reg.extension.enum.data.model
        
        reg.extension.enum.data.model =
            reg.enum.value.model |
            reg.extension.enum.relative.model
            
        reg.extension.enum.relative.model =
            reg.extension.enum.offset.attrib,
            reg.extension.enum.negate.attrib?
            
        reg.extension.remove.elem =
            ## Exactly like the feature version, but with an optional `api` tag.
            element remove { reg.extension.remove.contents }
            
        reg.extension.remove.contents =
            reg.extension.remove.attlist,
            reg.common.require.model,
            reg.extension.require.common.model,
            reg.extension.definition.model+,
            reg.feature.validity.elem?
        
        reg.extension.remove.attlist = empty
            
    }
}

## Attribute definitions
div
{
    reg.notation.attrib =
        ##A textual notation regarding a particular element 
        attribute notation { text }
    
    reg.any.name.attrib =
        ## String name for an element. Can contain any text.
        attribute name { text }
        
    reg.api.name.attrib =
        ## String name for a definition that is part of the Vulkan API.
        ## It *must* be a valid C/C++ identifier.
        attribute name { reg.identifier.data }

    reg.vendorid.id.attrib =
        ## Hexadecimal integer identifier for a vendor.
        ## TODO: make this actual hex.
        attribute id { text }
        
    reg.tag.author.attrib =
        ## Author name, usually a company or project
        attribute author { text }
        
    reg.tag.contact.attrib =
        ## Name and contact information for the person responsible for the tag
        attribute contact { text }

    reg.include.style.attrib =
        ## Specifies whether to use "" or <> around the include name.
        attribute style { "quote" | "bracket" }
        
    reg.include.need-ext.attrib =
        ## This specifies whether the processor needs to append a `.h` extension to the include name.
        ## This is only necessary for the special case of `vk_platform`, because the `.h` is
        ## not included in the name. In all other cases, it is.
        [ a:default-value = "false" ]
        attribute need-ext { reg.boolean.data }
        
    reg.typedef.basetype.attrib =
        ## Specifies the original typename for the typedef.
        ## This name should reference an existing definition.
        attribute basetype { reg.identifier.data }
        
    reg.reference.include.attrib =
        ## Specifies the include file that produces the name.
        ## This text should specify the name of an existing definition of
        ## type `include`.
        attribute include { text }
        
    reg.bitmask.enumref.attrib =
        ## Specifies the name of an enumerator that the bitmask gets its bits from.
        attribute enumref { reg.identifier.data }
        
    reg.define.disabled.attrib =
        ## If "true", then the processing system should add comments to each line of the 
        ## #define.
        ## That is, the #define exists, but has been commented out for some reason.
        [ a:default-value = "false" ]
        attribute disabled { reg.boolean.data }
    
    reg.define.replace.attrib =
        ## If "true", then the processor should not attempt to generate the #define
        ## statement at all. The entire c-expression will include the #define
        ## as well as the typename of the define.
        ## It is useful for very complex #defines.
        [ a:default-value = "false" ]
        attribute replace { reg.boolean.data }
        
    reg.define.value.attrib =
        ## A #define's value which represents something that is generally language neutral.
        ## A decimal number or string literal, for example.
        attribute value { text }

    reg.handle.parent.attrib =
        ## The name(s) of a handle object that is the parent of this handle.
        attribute parent { reg.csident.data }

    reg.handle.type.attrib =
        ## Whether the handle is dispatchable or not.
        attribute type { "dispatch" | "nodispatch" }

    reg.struct.is-return.attrib =
        ## When set to `true`, the struct is used only as a return value by the Vulkan API.
        [a:default-value = "false"]
        attribute is-return { reg.boolean.data }
    
    reg.struct.extends.attrib =
        ## A comma-separated list of identifiers that represent the top-level structure
        ## that this object can be within the `pNext` of.
        attribute extends { reg.csident.data } 
        
    reg.type.basetype.attrib =
        ## The fundamental typename of the variable. This names a definition.
        attribute basetype { reg.identifier.data }

    reg.type.const.attrib =
        ## If `true`, then the variable's base type is constant. If the type is
        ## a pointer or array, the `const` refers to the base type. So `const T *` rather
        ## than `T *const`.
        [a:default-value = "false"]
        attribute const { reg.boolean.data }
        
    reg.type.struct.attrib =
        ## If `true`, then the basetype name needs to be preceeded by the C keyword
        ## "struct" when interfacing with C.
        [a:default-value = "false"]
        attribute struct { reg.boolean.data }
    
    reg.type.reference.attrib =
        ## If present, then the variable is a pointer of some sort.
        ## This does not guarantee that variable is an *array*.
        attribute reference {
            ## Type is a pointer
            "pointer" |
             ## Type is a pointer-to-a-pointer, perhaps a dynamic array of pointers
            "pointer-pointer" |
            ## Type is a `* const *`. A dynamic array of const pointers to (possibly const) basetype.
            "pointer-const-pointer"
        }

    reg.type.static.array.attrib =
        ## The variable is a compile-time sized array.
        ## This will be rendered out with `[size]` in C/C++, where `size` is the
        ## associated `size` attribute
        attribute array { "static" }

    reg.type.static.array.size.attrib =
        ## The length of a static array variable, specified as an integer literal
        ## Must be present on all static arrays.
        attribute size { xsd:positiveInteger }
        
    reg.type.static.array.size-enumref.attrib =
        ## The length of a static array variable, specified as an enumerator reference.
        attribute size-enumref {reg.identifier.data}

    reg.type.dynamic.array.attrib =
        ## The variable is a runtime sized array.
        ## This will only be applied to pointer types. It spells out the difference
        ## between a pointer to a single object and a pointer as a dynamic array.
        attribute array { "dynamic" }

    reg.type.dynamic.array.size.attrib =
        ## The name of a construct, usually a member of the same struct or parameter to the same
        ## function that provides the size of a dynamic array.
        ## May also be a `latexmath:` expression, which may internally reference the
        ## name of a struct/parameter.
        ## Optional. If not present, then the dynamic array is either null-terminated or has no
        ## specific size.
        ## If the construct is a pointer-pointer, then this only specifies the size of the
        ## outer array.
        attribute size { text }
        
    reg.type.dynamic.array.null-terminate.attrib =
        ## If `true`, then a string variable (some form of pointer with the type `char`)
        ## is null-terminated. If the type is a `pointer-pointer` or a `pointer-const-pointer`,
        ## then the null-terminator refers only to the innermost string pointers.
        [a:default-value = "false"]
        attribute null-terminate { reg.boolean.data }
        
    reg.type.array.c-size.attrib =
        ## A C-expression that specifies the number of elements in a static or dynamic array.
        attribute c-size { reg.c-expression.data }

    reg.variable.optional.attrib =
        ## A sequence of comma-separated boolean values.
        ## Each boolean value represents a particular indirection, starting from the outermost
        ## pointer. The true/false represents whether that indirection is optional.
        ## For example, if an integer pointer type has `optional` set to `false,true`,
        ## this means that the pointer is required, but the integer value may be zero.
        [a:default-value = "false"]
        attribute optional { reg.csboolean.data }

    reg.variable.auto-validity.attrib =
        ## If set to "false", then auto-validation for the variable should not be generated.
        [a:default-value = "true"]
        attribute auto-validity { reg.boolean.data }
    
    reg.variable.sync.attrib =
        ## If present, will be either "true" or an expression that more explicitly
        ## describes how it must externally sync.
        ## If absent, then external synchronization is not necessary.
        attribute sync { "true" | text }
        
    reg.variable.inout.attrib =
        ## Determines whether the variable is used as an input, output, or both.
        [a:default-value = "in"]
        attribute inout { "in" | "out" | "inout" }
    
    reg.struct.member.extension-structs.attrib =
        ## Comma-separated list of structs that this member can be used with.
        attribute extension-structs { reg.csident.data }
        
    reg.struct.member.type-enums.attrib =
        ## Comma-separated list of enumerators that this member can be given.
        attribute type-enums { reg.csident.data }
    
    reg.enum.number.attrib =
        ## An enumerator/constant value which is just an integer number.
        attribute number { xsd:integer }
    
    reg.enum.hex.attrib =
        ## Specifies a hexadecimal integer that represents all the bits set by this mask.
        ## Not prefixed with "0x".
        attribute hex { reg.hexadecimal.data }
        
    reg.enum.bitpos.attrib =
        ## Specifies the index of the bit to set for this field.
        attribute bitpos { xsd:nonNegativeInteger }
        
    reg.enum.c-expression.attrib =
        ## A C-expression defining an enumerator/constant's value.
        ## These could be a floating-point number or a more complex expression
        ## such as (~0LL) or somesuch
        attribute c-expression { text }

    reg.enum.purpose.attrib =
        ## Identifies a special meaning behind the enumeration.
        ## "bitmask" means that the enumerators are either specific bits or
        ## combinations of bits. There should be a `bitmask` definition
        ## attribute which uses this enumeration as the source for its enums.
        attribute purpose { "bitmask" }

    reg.enum.range-start.attrib =
        ## Beginning of an enumerator value range
        attribute range-start { xsd:integer }
    
    reg.enum.range-end.attrib =
        ## End fo an enumerator value range
        attribute range-end { xsd:integer }
        
    reg.command.successcodes.attrib =
        ## Specifies the return codes that represent successful function execution.
        ## When not specified, then the command doesn't return `VkResult`
        attribute successcodes { reg.csident.data }

    reg.command.errorcodes.attrib =
        ## Specifies the return codes that represent error conditions.
        ## When not specified, either the command doesn't return `VkResult` or it cannot "fail".
        attribute errorcodes { reg.csident.data }
        
    reg.command.renderpass.attrib =
        ## Specifies how the command may be called, relative to render pass instance scopes.
        ## When not specified, the command does not care about render pass scoping,
        ## or the command isn't a vkCmd command.
        attribute renderpass { "inside" | "outside" | "both" }
        
    reg.command.cmdbufferlevel.attrib =
        ## Specifies the level of command buffer that the command can be used with.
        ## When not specified, the command does not go into a command buffer.
        attribute cmdbufferlevel { "primary" | "secondary" | "primary,secondary" }
        
    reg.command.pipeline.attrib =
        ## Specifies the kind of pipeline that a command can be used with.
        attribute pipeline { "graphics" | "compute" | "transfer" }

    reg.command.queues.attrib =
        ## Comma-separated list of queues that support this operation.
        ## When not specified, the function cannot be used in a queue.
        attribute queues { reg.csident.data }
    
    reg.command-alias.target.attrib =
        ## Specifies the target name of the alias. This may be another alias,
        ## so long as the eventual chain of targets leads to an actual command.
        attribute target { reg.identifier.data }
        
    reg.feature.api.attrib =
        ## The name of the API that a feature defines.
        attribute api { text }

    reg.feature.version.attrib =
        ## Version number for the feature.
        attribute version { xsd:float }

    reg.feature.define.attrib =
        ## When generating C-style information, use this as the #define wrapper
        ## around this feature.
        attribute define { reg.identifier.data }

    reg.feature.profile.attrib =
        ## The name of the API profile which this specialization element
        ## is associated. All specified requirements/exclusions apply
        ## only to that profile.
        attribute profile { text }

    reg.feature.usage.struct.attrib =
        ## Specifies the name of a <struct> which this `usage` statement extends.
        attribute struct { reg.identifier.data }
        
    reg.require.extension.attrib =
        ## Specifies the name of an extension which this `require` statement needs
        ## for its inclusions to be imported.
        attribute extension { reg.identifier.data }

    reg.feature.usage.command.attrib =
        ## Specifies the name of a <command> which this `usage` statement extends.
        attribute command { reg.identifier.data }

    reg.extension.number.attrib =
        ## The extension's registration number.
        ## Used to compute the offsets for enumerators and the like.
        attribute number { xsd:positiveInteger }
    
    reg.extension.disabled.attrib =
        ## Specifies that the extension is disabled. If it is not present, then the extension is
        ## enabled.
        attribute disabled { "true" }
        
    reg.extension.match-api.attrib =
        ## A regex used to match an `api` tag on a `feature` element.
        ## If it matches, then the extension can be used with that API.
        attribute match-api { text }
        
    reg.extension.type.attrib =
        ## Specifies the kind of extension: instance or device.
        attribute type { "instance" | "device" }
    
    reg.extension.requires.attrib =
        ## A comma-separated list of identifiers, specifying
        ## extensions this extension requires in order to function.
        attribute requires { reg.csident.data }

    reg.extension.author.attrib =
        ## The name of the author of an extension, typically a company.
        ## When absent, can be gleamed by using the `name` and parsing out the
        ## author part of the name, then finding the corresponding `tag` element.
        attribute author { text }

    reg.extension.contact.attrib =
        ## The name and contact info for the person who is responsible for
        ## the extension. Can be inferred in the same way as `author`.
        attribute contact { text }

    reg.extension.api.attrib =
        ## Specifies that the extensions or removals only apply to that specific
        ## API being generated. If not present, it applies to all APIs.
        attribute api { text }

    reg.extension.constant.string.attrib =
        ## An arbitrary string constant. The string here is not contained in quotes.
        ## So you should add your own.
        attribute string { text }

    reg.extension.constant.enumref.attrib =
        ## Specifies a constant who's value comes from an enum
        ## or another existing constant.
        attribute enumref { reg.identifier.data }

    reg.extension.enum.extends.attrib =
        ## The name of an `enumeration` to be extended.
        attribute extends { reg.identifier.data }
     
    reg.extension.enum.offset.attrib =
        ## Compute the enum's value based on an integer offset.
        attribute offset { xsd:nonNegativeInteger }
    
    reg.extension.enum.negate.attrib =
        ## If true, the offset's value should be negated.
        ## Primarily for error codes.
        [a:default-value = "false"]
        attribute negate { reg.boolean.data }

}

## Data types
div
{
    ## Represents text formatted in accord with the Vulkan standard.
    ## Such text can be copied and pasted into the spec, using the spec's
    ## format.
    reg.spec-language.data = text

    ## Should be a valid C/C++ identifier.
    reg.identifier.data = xsd:string{pattern = "[A-Za-z_][A-Za-z0-9_]*"}
    
    ## Comma-separated identifiers values.
    ## Can be empty.
    reg.csident.data = xsd:string{pattern =
        "([A-Za-z_][A-Za-z0-9_]*(,([A-Za-z_][A-Za-z0-9_]*))*)?"}
    
    ## Recognize a hexadecimal number.
    ## Not prefixed with "0x"
    reg.hexadecimal.data = xsd:string{pattern = "[A-Fa-f0-9]+"}
    
    ## XSD's boolean type includes things other than "true" and "false",
    ## so we do it manually.
    reg.boolean.data = "true" | "false"
    
    ## Comma-separated boolean values.
    reg.csboolean.data = xsd:string{pattern = "(true|false)(,(true|false))*"}
    
    ## Text that is an expression in C.
    reg.c-expression.data = text
}

## Supplementary elements and definitions.
div
{
    
    INCOMPLETE = empty
}
